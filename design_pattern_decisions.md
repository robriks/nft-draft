Discussion of Smart Contract Design Pattern Decisions

Inheritance

The HornMarketplace NFT contract makes use of two libraries that provide secure and audited solutions to problems that arise when handling the exchange of real-world backed NFTs.
The first is OpenZeppelin's Counters.sol utility contract, which provides a very simple and very secure counter functionality that can only be incremented, decremented, or returned. I used this contract to prevent any enumeration, overflow, or repetition of the Horn NFT tokenId, in this case called hornId. This is an especially useful solution as it is paramount that malicious actors not be able to manipulate or duplicate tokenIds.
The second is OpenZeppelin's Escrow.sol contract, which is a standalone instantiated contract that handles the reception and release of ETH in an escrow structure. This facilitates the trustless exchange of the Horn NFTs which represent valuable ($4000-$20000!) real-world assets, in this case musical instruments. The escrow contract features functions internal to the Marketplace and is never called directly by users as it inherits OpenZeppelin's Ownable.sol contract and is therefore explicitly owned and interacted with only by the Marketplace contract. This prevents any sort of logic attack vectors that would be an issue for an escrow contract with functions freely callable by malicious actors.

Access Control
The HornMarketplace NFT contract makes use of unconventional access control, namely to restrict certain functions calls to only the currentOwners, sellers, and buyers of Horn NFTs. This was implemented to ascertain both the shipping/delivering process and the interactions between the marketplace contract and its instantiated escrow contract, which handles the payment for a Horn NFT. For example, only the currentOwner of a minted Horn NFT may list it for sale, only the Seller of a Horn NFT may mark it as Shipped (which also approves the Buyer address), and only the Buyer of a specific Horn NFT may mark it as delivered and finalize the transfer of the NFT (completing the approval which was given at shipping time). These access modifiers provide a reliable, trustless framework for the uncertain process of listing, selling, shipping, and receiving an expensive instrument across the internet and real world.

Bonus: Inter-Contract Execution via testing
Because I wrote the vast majority of my test functions in Solidity and not in Javascript (to delve as deep into the language as possible over the course of the bootcamp), I also made use of inter-contract execution as a design pattern in order to simulate the behavior of EOA (end users) who acted as buyers and sellers of the Horn NFT during the transfer process. My main test contract instantiates a separate, standalone Buyer and Seller contract which call the HornMarketplace's functions in various orders to prove the functionality of the marketplace and behave as an end user might, both legitimately and maliciously. Originally, I used @remix-project's remix-tests framework to write my test functions using their nifty natspec comments to manipulate the value of msg.sender and msg.value as follows:
```/// #sender: accounts-1```
```/// #value: 1000```
But I wanted to challenge myself and learn how contrats interacted with one another on a more intimate level. Future endeavors will see me learning the intricacies of the EVM, assembly, and low-level calls in Solidity in combination with the abi.encoding options.
