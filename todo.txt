--use ConditionalEscrow from openzeppelin for this? have the modifier return true only when matching roles call functions

Web-App:
  -homepage marketplace.com: 
    /mint Mint your instrument as an NFT! 
      -ideal UI on marketplace.com/mint page is single question: 
        -Are you minting your horn as an NFT to list it for sale? If you are minting a Horn NFT to establish a verifiable and immutable record of ownership, select No.
          Yes/No: mintThenListNewHornNFT() / mintButDontListNewHornNFT()
    /about HornMarketplace is a place for you to interface with the Ethereum blockchain ...
    /marketplace Check out the great horns listed for sale!
      -reads getHornsForSale() function from marketplace contract (returns array uint[] of all horns for sale)
        -use returned hornIds to render component that displays information (images, struct attributes like make model style price) pulled from the corresponding tokenUri which points to this stored information
          -MUST require hornId > 0 because the hornsForSale[] array will NOT clear values and instead will reset indexed values to 0
      -allow for reports of glitches, bugs, fraudulent listings
    /horns See what horns people own! Here you'll find all the Horn NFTs in existence, mapped to their owners/players. What horn does your favorite horn player play?
    /FAQ What are NFTs? What is Ethereum? Who cares? Why Ethereum and not Solana or _insert_random_crypto_here?
  -note that formatting of NFT data input must be EXPLICITLY outlined or all NFTs will not be uniform and events emitted will suck
    ie _make: Type only the manufacturer/builder's name here (eg "Lewis", "Rauch") // _model: Type only the model (eg ) OR "single"/"double"/"triple" here // and so forth for each parameter. explicitness fights user error
  -marketplace can loop over the market contracts hornsForSale[] uint[]array in order to show the horns currently for sale

  -watch tutorials on scaffold-eth for faster front-end developing using react
  -utilize tenderly for event emission subscription for a faster front-end? free
  -utilize netlify + create-react-app to build front end?
  -maybe use heroku? netlify looks easier
-consider network UX/UI: make connected network clear (mainnet v arbitrum)
-Explain transaction mining & gas considerations on UI

Escrow contract:
 -refunds must be supported to combat fraud (ie buyer pays but never receives item)
   -Access control in ESCROW ctrct will be necessary to make sure buyer funds cannot be withdrawn after purchase
   -refunds cannot be free to call by default or else buyers can pay then refund themselves once item is shipped
     -maybe only allow refund function to be called until item is shipped, after which point funds are locked & a contract owner must step in to recover funds in case of incident (what if mail loses package)
     -how does contract owner know truth of situation? perhaps receipts of shipping & case filing must be provided to frontend
 -how to accept ERC20 token deposits (stables ie USDC, USDT, DAI) in ESCROW smart contract & communicate that to NFT market contract


Horn NFT Contract:
-consider splitting horn marketplace into several components:
--horn factory / horn marketplace / horn shipping
-consider HASHING sensitive shipping addresses on the front end in order to only store the address hash on chain for privacy reasons
-is an approvals mapping necessary? is the 721 functionality being preserved properly even with my different variable/mapping names?
-how to store images of instruments 
  -tokenURI metadata
  -hosted on front end website
-review events

Test Contract:
-certain tests cannot be carried out in Solidity via a testing smart contract: notably EVENTS, LOGS must be done in javascript
-change nested test helper functions by removing assert() line and simply rework helpers to return bool or other value and then compare in a final assert() in larger host functions
  change their names from testblabedyblabla to returnGetWhateverValue and put that helper function into assert like so: assert(returnGetWhateverValue, expectedValue)
-look closely at how PAYABLE functions (prepareForShipped) are tested: msg.value needs to be included within the test AND matched to exactly the listPrice attribute of each NFT struct
  use web3 {value: 420} ?
-consider moving Seller and Buyer contract into separate files
-check how Enum values are passed into test values as a parameter. Consider wrapping in uint(HornStatus.forSale) or using forSale instead of HornStatus.forSale. or maybe just plain uints 0, 1, 2?
-write tests for tokenURI logic


Escrow + Marketplace interfacing:
 -how to list NFT horn via price vs auction (look at OPENSEA)


 Future functionality given extra time:
  -how to use NFT contract to listen for deposits of said stablecoins (to mark as paid & initiate shipping)
  -approve/safetransfer double call thing
  -trial weeks embedded in NFT ownership transfer process?
  -how to create addresses on-chain? for ease of use (orchestra boomer users don't need to know they are using blockchain) 
